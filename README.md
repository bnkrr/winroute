# winroute

`winroute` is a modern, user-friendly Go library for manipulating the Windows routing table. It's built on top of the robust `golang.zx2c4.com/wireguard/windows/tunnel/winipcfg` package, providing a higher-level, more intuitive API for common routing tasks.

The project also includes `wroute`, a powerful command-line tool for managing routes directly from your terminal.

The project is heavily dependent on Gemini. For instance, this README is generated by Gemini except for this paragraph.

## Features

*   **Modern Go API**: Uses idiomatic Go, including the `net/netip` package for type-safe IP addresses and prefixes.
*   **Rich Object Model**: Works with enriched `Route` and `Interface` objects, providing aggregated information like interface aliases and descriptions, not just raw system data.
*   **Fluent Filtering**: Easily query the routing table with a flexible, chainable filtering system.
*   **Safe Bulk Operations**: Perform batch deletions with configurable error handling (stop on error or continue).
*   **Powerful CLI**: Comes with `wroute`, a feature-complete command-line interface for easy route management.

## Library Usage

### Installation

```sh
# Replace with your actual module path
go get github.com/your-username/winroute
```

### Getting Routes

```go
package main

import (
	"fmt"
	"log"
	"net/netip"
	"winroute"
)

func main() {
	// Get all routes
	allRoutes, err := winroute.GetRoutes()
	if err != nil {
		log.Fatalf("Failed to get all routes: %v", err)
	}
	fmt.Printf("Found %d routes in total.\n", len(allRoutes))

	// Get routes for a specific destination using a filter
	prefix := netip.MustParsePrefix("10.0.0.0/24")
	googleDnsRoutes, err := winroute.GetRoutes(winroute.WithDestinationPrefix(prefix))
	if err != nil {
		log.Fatalf("Failed to get filtered routes: %v", err)
	}

	for _, r := range googleDnsRoutes {
		fmt.Printf("Route to %s via %s on interface '%s' (Index: %d)\n",
			r.Destination, r.NextHop, r.Interface.Alias, r.Interface.Index)
	}
}
```

### Adding a Route

```go
dest := netip.MustParsePrefix("10.99.0.0/16")
nextHop := netip.MustParseAddr("192.168.1.1")
ifaceIndex := uint32(12)
metric := uint32(25)

err := winroute.AddRoute(dest, nextHop, ifaceIndex, metric)
if err != nil {
	log.Fatalf("Failed to add route: %v", err)
}
fmt.Println("Route added successfully!")
```

### Deleting Routes

```go
// Delete all routes on a specific interface
partialErrs, err := winroute.DeleteRoutes(
	winroute.WithInterfaceAlias("Ethernet 2"),
	// Default behavior is to continue on error.
	// To stop on the first error, add: winroute.ErrorActionStop
)
if err != nil {
    log.Fatalf("A fatal error occurred: %v", err)
}
if len(partialErrs) > 0 {
	log.Printf("Encountered %d errors during deletion:", len(partialErrs))
	for _, e := range partialErrs {
		log.Println(e)
	}
} else {
	fmt.Println("Routes deleted successfully.")
}
```

## CLI Tool (`wroute`) Usage

### Building

From the project root directory:
```sh
GOOS=windows GOARCH=amd64 go build ./cmd/wroute # cross-platform building
```
This will create `wroute.exe` in the current directory.

### Commands

#### Get Routes
```sh
# Get all routes
wroute get

# Get routes for a specific destination
wroute get --destination 192.168.1.0/24

# Get routes using a specific interface alias (case-insensitive, works with Chinese)
wroute get --if-alias "以太网"
```

#### Add a Route
```sh
# Add a route to 10.20.0.0/16 via 192.168.1.254 on interface 15 with metric 100
wroute add -d 10.20.0.0/16 -n 192.168.1.254 -i 15 -m 100
```

#### Delete Routes
```sh
# Delete a single, specific route by its exact properties
wroute delete-one -d 10.20.0.0/16 -n 192.168.1.254 -i 15

# Delete all routes matching a filter (e.g., all routes on interface 15)
# WARNING: Use filters with caution.
wroute delete -i 15
```

## License

This project is licensed under the MIT License.
